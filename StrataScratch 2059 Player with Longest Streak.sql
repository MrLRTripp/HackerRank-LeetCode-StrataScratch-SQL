set search_path to data_sci

-- Tennis player streak
create TYPE w_or_l as enum ('W','L');

drop table player_data

create table player_data (
id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
player_name   TEXT,
match_date  date,
match_result w_or_l)

select (extract (day from (current_date + concat('-2',' day')::interval)))

-- Start from current date and go back in time to create historical data
insert into player_data
(player_name, match_date, match_result)
select concat('Player',(num%10)::text) , 
	(current_date + concat(((-1*num)::text), ' day')::interval),
	case
		when random() >0.5 then 'W'::w_or_l
		else 'L'::w_or_l
	END
from generate_series(1,200,1) as num;

select * from player_data
limit 20


-- Find longest streak
select player_name, 
array_agg(match_result order by match_date asc),
array_positions(array_agg(match_result order by match_date asc),'L') as loss,
array_positions(array_agg(match_result order by match_date asc), 'W') as win
from player_data
group by player_name

select player_name,
match_result,
lead(match_result,1) over (partition by player_name order by match_date),
lag(match_result,1) over (partition by player_name order by match_date)
from player_data
where player_name = 'Player2'
ORDER by match_date

select regexp_matches('WWWWLLLWLLLLWWLLWWWWWWL','W+','g')

with wlcte as (
	select player_name, 
	string_agg(match_result::text ,'' order by match_date ASC) as wlhistory
	from player_data
	group by player_name),
streakcte as (
	select player_name,
	regexp_matches(wlhistory,'W+','g') as streak
	from wlcte),
rankingcte as(
	select player_name,
	streak,
	char_length(streak[1]) as win_streak,
	rank() over (order by char_length(streak[1]) desc) as ranking
	from streakcte
	)
select player_name, win_streak
from rankingcte
where ranking = 1


-- Combined regexp and string_agg on one line.
-- If you execute the first select, you will see each win streak for each player.
-- Then it is simple to count the characters and rank.
-- Note: match_result is an enum I created. It has to be cast to text for string_agg
-- i.e. match_result::text
-- Note: regexp_matches returns arrays of char with a single element. That is why you have
-- to use array reference to element 1, i.e. char_length(streak[1])
with wlcte as (
	select player_name, 
	regexp_matches(string_agg(match_result::text ,'' order by match_date ASC),'W+','g') as streak
	from player_data
	group by player_name),
rankingcte as(
	select player_name,
	streak,
	char_length(streak[1]) as win_streak,
	rank() over (order by char_length(streak[1]) desc) as ranking
	from wlcte
	)
select player_name, win_streak
from rankingcte
where ranking = 1

-- output name and length of streak

-- Instructor solution is to create a column so that each streak has a different identifier
-- he does this using row_number over (partition by player_name order_by match_date asc)
-- and subtracting row_number over (partition by player_name,match_result order_by match_date asc)
-- Since we are partitioning over two columns the row number gets reset when
-- match result changes for a player
-- 

